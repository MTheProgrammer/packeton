security:
    enable_authenticator_manager: true
    # https://symfony.com/doc/current/security.html#registering-the-user-hashing-passwords
    password_hashers:
        Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface:
            algorithm: auto
            migrate_from: [legacy]

        legacy:
            algorithm:        sha512
            encode_as_base64: false
            iterations:       1

    providers:
        packagist:
            id: Packeton\Security\Provider\UserProvider

    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
        packages:
            pattern: (^(.+\.json$|/p/|/zipball/|/feeds/.+(\.rss|\.atom)|/packages/[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+?(\.json|/changelog)|/packages/list\.json|/downloads/|/api/))+
            api_basic: true
            stateless: true
            context: main
            user_checker: Packeton\Security\UserChecker

        main:
            lazy: true
            pattern:      .*
            user_checker: Packeton\Security\UserChecker
            form_login:
                provider:       packagist
                login_path:     /login
                use_forward:    false
                check_path:     /login
                failure_path:   null

            remember_me:
                secret: '%env(APP_SECRET)%'
                user_providers: packagist
                name: pauth
                always_remember_me: true
                lifetime: 31104000 # 1y
            logout:       true

    # Easy way to control access for large sections of your site
    # Note: Only the *first* access control that matches will be used
    access_control:
        # The WDT has to be allowed to anonymous users to avoid requiring the login with the AJAX request
        - { path: ^/_wdt/, roles: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/_profiler/, roles: IS_AUTHENTICATED_ANONYMOUSLY }

        - { path: ^/login$, roles: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/login/, roles: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/reset-password, roles: IS_AUTHENTICATED_ANONYMOUSLY }

        # Packagist
        - { path: (^(/change-password|/profile|/logout))+, roles: ROLE_USER }
        - { path: (^(/search|/packages/|/versions/))+, roles: ROLE_USER, allow_if: "is_granted('PACKETON_PUBLIC')" }
        - { path: (^(/packages.json$|/p/|/p2/|/downloads/))+, roles: ROLE_USER, allow_if: "is_granted('PACKETON_PUBLIC')" }
        - { path: (^(/zipball/))+, roles: ROLE_USER, allow_if: "is_granted('PACKETON_ARCHIVE_PUBLIC')" }
        - { path: (^(/api/webhook-invoke/))+, roles: ROLE_USER }
        - { path: (^(/api/(create-package|update-package|github|bitbucket)))$, roles: ROLE_MAINTAINER }
        - { path: ^/$, roles: ROLE_USER, allow_if: "is_granted('PACKETON_PUBLIC')" }

        # Maintainers
        - { path: (^(/users/(.+)/packages))+, roles: ROLE_MAINTAINER }
        - { path: (^(/users/(.+)/favorites))+, roles: ROLE_MAINTAINER }
        - { path: (^(/explore|/jobs/))+, roles: ROLE_MAINTAINER }

        # Secured part of the site
        # This config requires being logged for the whole site and having the admin role for the admin part.
        # Change these rules to adapt them to your needs
        - { path: ^.*$, roles: ROLE_ADMIN }

    role_hierarchy:
        ROLE_UPDATE_PACKAGES: ~
        ROLE_DELETE_PACKAGES: ~
        ROLE_EDIT_PACKAGES: ~
    
        ROLE_FULL_CUSTOMER: [ ROLE_USER ] # Access to all packages without ACL group restriction
        ROLE_MAINTAINER:  [ ROLE_FULL_CUSTOMER, ROLE_USER, ROLE_UPDATE_PACKAGES, ROLE_EDIT_PACKAGES, ROLE_DELETE_PACKAGES ]
        ROLE_ADMIN:       [ ROLE_MAINTAINER ]
        ROLE_SUPERADMIN:  [ ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH ]
